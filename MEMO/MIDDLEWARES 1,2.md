** Middlewares part.1 **

1. 미들웨어는 요청과 응답 사이의 소프트웨어입니다.
2. 모든 미들웨어는 취급자예요. 모든 컨트롤러는 미들웨어입니다.
3. 그들은 다음 논쟁을 포함해 세 가지 주장을 해. (req, res, next)
4. 다음 인수는 다음 핸들러 함수가 있는 경우 [next()]를 호출합니다.
예를 들어, 아래 코드를 고려해보자!

미들웨어 "1"로 시작하지만, 다음 번이 호출되었기 때문에 결국 컨트롤러 "3"로 끝납니다.
 미들웨어 "1"과 "2"의 본체 안에 코드를 넣어 컨트롤러 "3"에 도달하기 전에 무언가를 확인할 수 있습니다.
const = (req,res,next) => {
다음 사람;
}
const 2 = (req,res,next) => {
다음 사람;
}
const 3 = (req,res) => {
console.log("지금 3개가 처리 중입니다")
}

app.get은 "1" 핸들러를 사용하여 "/" URL을 방문하는 사용자를 처리합니다.
app.gets/, 하나, 둘, 셋)

** Middlewares part.2 **

app.use: 글로벌 미들웨어를 만들 수 있습니다.
- Global middlewares : 모든 URL에서 작동하는 미들웨어
모든 경로에서 기능을 사용할 수 있습니다.
- 맨 위에 미들웨어를 놓으면 다른 모든 경로에서 미들웨어를 사용하게 됩니다.

app.use(gossipMiddleware);
app.get("/", handleHome);
- 순서가 중요합니다.
- 익스프레스는 JS와 같은 모든 것을 위에서 아래로 순서대로 실행한다.

모든 핸들러, 모든 구성 요소에는 req, res 및 next가 있습니다.
필요하다면 모든 컨트롤러에는 'next'가 있습니다.

const privateMiddleware = (req, res, next) => {
const url = req.url;
if (url === "/protected") {
res.send("허용되지 않음")를 반환합니다.
}
console.log("허용됨, 계속할 수 있습니다.");
next();
}; // 이 미들웨어는 컨트롤러가 됩니다.

미들웨어는 일반 컨트롤러와 다름없지만 next이라는 argument가 하나 더 붙는다.
- 미들웨어가 next()라고 부르지 않으면 next 기능은 절대 실행되지 않습니다.
- 미들웨어가 무언가를 반환하면 연결이 중단됩니다.
- 어떤 미들웨어는 next 함수를 부르고 어떤 미들웨어는 res.send()를 사용한다.

여기에서 모든 기능('app.get("/", loger, handleHome;')은 미들웨어 또는 컨트롤러일 수 있습니다.
함수가 next를 부르면 미들웨어가 된다.
다른 컨트롤러가 res.send를 호출하면 미들웨어 B/c가 아니라 기능이 꺼진다.
- 미들웨어는 왼쪽에서 오른쪽으로 읽습니다.